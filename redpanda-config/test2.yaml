# ============================================
# Redpanda Connect: PostgresQL â†’ ClickHouse (Deduped + Batched)
# ============================================
input:
  generate:
    interval: "2s" # Configure batch time
    mapping: "root = {}"
  processors:
    - branch:
        processors:
          - cache:
              resource: batchcache
              operator: get
              key: batch_number
        result_map: "root.batch_number = this" # if the key exist in cache it will return its value
      # We need this mapping because if this = null we can't convert directly to 0
    - mapping: |
        root.batch_number = this.batch_number.or(0)
    - cache:
        resource: batchcache
        operator: set
        key: batch_number
        value: ${! this.batch_number + 1 }
    - log:
        level: INFO
        message: "Fetching rows with batch = ${! this.batch_number }"

    # Order Created
    - branch:
        processors:
          - sql_raw:
              driver: postgres
              dsn: "postgres://postgres:password@db:5432/shopify_data_pruned?sslmode=disable"
              query: |
                SELECT *
                FROM (
                SELECT DISTINCT ON (o.id)
                md5(
                concat_ws(
                '::',
                'free-soul-sistas',
                o.created_at::text,
                'order_created',
                CASE
                WHEN 'Subscription Recurring Order' = ANY (o.tags) THEN 'recurring'
                WHEN 'Subscription First Order' = ANY (o.tags) THEN 'first'
                WHEN so.subscription_id IS NULL THEN 'onetime'
                END,
                s.id::text,
                o.id::text
                )
                )                                                    AS event_id,
                'free-soul-sistas'                                   AS tenant_id,
                o.created_at                                         AS event_time,
                'order_created'                                      AS event_type,
                'active'                                             AS status_after,
                so.subscription_id                                   AS subscription_id,
                o.customer_id                                        AS customer_id,
                CASE
                WHEN 'Subscription Recurring Order' = ANY (o.tags) THEN 'recurring'
                WHEN 'Subscription First Order' = ANY (o.tags) THEN 'first'
                WHEN so.subscription_id IS NULL THEN 'onetime'
                END                                                  AS revenue_type,

                COALESCE((
                CASE
                WHEN 'Subscription Recurring Order' = ANY (o.tags)
                THEN ((o.total_price - o.total_tax - coalesce(sh.total, 0)) - COALESCE(li.total, 0))
                ELSE (o.total_price - o.total_tax - coalesce(sh.total, 0))
                END * 100
                )::bigint, 0)                                        AS price_cents,

                COALESCE((o.total_tax * 100)::bigint, 0)             AS tax_cents,
                COALESCE((sh.total * 100)::bigint, 0) AS shipping_cents,

                CASE
                WHEN bp.interval = 'DAY' THEN bp.frequency * 1
                WHEN bp.interval = 'WEEK' THEN bp.frequency * 7
                WHEN bp.interval = 'MONTH' THEN bp.frequency * 30
                WHEN bp.interval = 'YEAR' THEN bp.frequency * 365
                ELSE 30
                END                                                  AS interval_days,

                sp.name                                              AS plan_id,
                NULL                                                 AS region,
                o.source                                             AS channel,
                o.currency                                           AS currency,
                NULL                                                 AS cancellation_reason,
                NULL                                                 AS pause_reason
                FROM orders o
                LEFT JOIN shipments sh on sh.order_id = o.id
                LEFT JOIN subscription_orders so ON o.id = so.order_id
                LEFT JOIN subscriptions s ON so.subscription_id = s.id
                LEFT JOIN billing_policies bp ON bp.subscription_id = s.id
                LEFT JOIN selling_plans sp ON sp.id = bp.selling_plan_id
                LEFT JOIN (
                SELECT order_id, SUM(total) AS total
                FROM line_items
                WHERE deleted_at is null
                and properties LIKE '%{"name"=>"one_off", "value"=>"true"}%'
                OR properties LIKE '%{"value"=>"true", "name"=>"one_off"}%'
                GROUP BY order_id
                ) li ON o.id = li.order_id
                WHERE o.state NOT IN ('cancelled')
                ) AS query
                WHERE event_time >= '2025-09-01' and event_time < '2025-10-01'
                ORDER BY event_time DESC
                LIMIT $1 OFFSET $2;
              args_mapping: |
                root = [2500, this.batch_number * 2500]
        result_map: "root.order_created = this"
    # Sub Created
    - branch:
        processors:
          - sql_raw:
              driver: postgres
              dsn: "postgres://postgres:password@db:5432/shopify_data_pruned?sslmode=disable"
              query: |
                SELECT *
                FROM (
                SELECT md5(
                concat_ws(
                '::',
                'free-soul-sistas',
                s.created_at::text,
                'sub_created',
                CASE
                WHEN 'Subscription Recurring Order' = ANY (o.tags) THEN 'recurring'
                WHEN 'Subscription First Order' = ANY (o.tags) THEN 'first'
                END,
                s.id::text,
                o.id::text
                )
                )                                                    AS event_id,
                'free-soul-sistas'                                   AS tenant_id,
                s.created_at                                         AS event_time,
                'sub_created'                                        AS event_type,
                'active'                                             AS status_after,
                s.id                                                 AS subscription_id,
                s.customer_id                                        AS customer_id,
                CASE
                WHEN 'Subscription Recurring Order' = ANY (o.tags) THEN 'recurring'
                WHEN 'Subscription First Order' = ANY (o.tags) THEN 'first'
                END                                              AS revenue_type,
                coalesce(((o.total_price - o.total_tax - coalesce(s.delivery_price_amount, 0)) * 100)::bigint, 0)        AS price_cents,
                coalesce((o.total_tax * 100)::bigint, 0)             AS tax_cents,
                coalesce((s.delivery_price_amount * 100)::bigint, 0) AS shipping_cents,
                CASE
                WHEN bp.interval = 'DAY' THEN bp.frequency * 1
                WHEN bp.interval = 'WEEK' THEN bp.frequency * 7
                WHEN bp.interval = 'MONTH' THEN bp.frequency * 30
                WHEN bp.interval = 'YEAR' THEN bp.frequency * 365
                ELSE 30
                END                                              AS interval_days,
                sp.name                                                 AS plan_id,
                NULL                                                 AS region,
                s.source                                             AS channel,
                s.currency_code                                      AS currency,
                NULL                                                 AS cancellation_reason,
                NULL                                                 AS pause_reason
                FROM subscriptions s
                JOIN orders o on s.origin_order_id = o.id
                LEFT JOIN billing_policies bp ON bp.subscription_id = s.id
                LEFT JOIN selling_plans sp ON sp.id = bp.selling_plan_id
                WHERE o.state NOT IN ('cancelled', 'refunded')
                ) AS query
                WHERE event_time >= '2025-09-01' and event_time < '2025-10-01'
                ORDER BY event_time DESC
                LIMIT $1 OFFSET $2;
              args_mapping: |
                root = [2500, this.batch_number * 2500]
        result_map: "root.sub_created = this"
    # Sub Paused
    - branch:
        processors:
          - sql_raw:
              driver: postgres
              dsn: "postgres://postgres:password@db:5432/shopify_data_pruned?sslmode=disable"
              query: |
                SELECT *
                FROM (
                SELECT md5(
                concat_ws(
                '::',
                'free-soul-sistas',
                st.created_at::text,
                'sub_paused',
                CASE
                WHEN 'Subscription Recurring Order' = ANY (o.tags) THEN 'recurring'
                WHEN 'Subscription First Order' = ANY (o.tags) THEN 'first'
                END,
                s.id::text,
                o.id::text
                )
                )                                                    AS event_id,
                'free-soul-sistas'                                   AS tenant_id,
                st.created_at                                        AS event_time,
                'sub_paused'                                         AS event_type,
                'paused'                                             AS status_after,
                st.subscription_id                                   AS subscription_id,
                s.customer_id                                        AS customer_id,
                CASE
                WHEN 'Subscription Recurring Order' = ANY (o.tags) THEN 'recurring'
                WHEN 'Subscription First Order' = ANY (o.tags) THEN 'first'
                END                                              AS revenue_type,
                coalesce(((o.total_price - o.total_tax - coalesce(s.delivery_price_amount, 0)) * 100)::bigint, 0)        AS price_cents,
                coalesce((o.total_tax * 100)::bigint, 0)             AS tax_cents,
                coalesce((s.delivery_price_amount * 100)::bigint, 0) AS shipping_cents,
                CASE
                WHEN bp.interval = 'DAY' THEN bp.frequency * 1
                WHEN bp.interval = 'WEEK' THEN bp.frequency * 7
                WHEN bp.interval = 'MONTH' THEN bp.frequency * 30
                WHEN bp.interval = 'YEAR' THEN bp.frequency * 365
                ELSE 30
                END                                              AS interval_days,
                sp.name                                               AS plan_id,
                NULL                                                 AS region,
                s.source                                             AS channel,
                s.currency_code                                      AS currency,
                NULL                                                 AS cancellation_reason,
                NULL                                                 AS pause_reason
                FROM subscription_transitions st
                JOIN subscriptions s ON st.subscription_id = s.id
                JOIN orders o on s.origin_order_id = o.id
                LEFT JOIN billing_policies bp ON bp.subscription_id = s.id
                LEFT JOIN selling_plans sp ON sp.id = bp.selling_plan_id
                WHERE to_state IN ('paused', 'skipped')
                AND o.state NOT IN ('cancelled', 'refunded')
                ) AS query
                WHERE event_time >= '2025-09-01' and event_time < '2025-10-01'
                ORDER BY event_time DESC
                LIMIT $1 OFFSET $2;
              args_mapping: |
                root = [2500, this.batch_number * 2500]
        result_map: "root.sub_paused = this"
    # Sub Cancelled
    - branch:
        processors:
          - sql_raw:
              driver: postgres
              dsn: "postgres://postgres:password@db:5432/shopify_data_pruned?sslmode=disable"
              query: |
                SELECT *
                FROM (
                SELECT md5(
                concat_ws(
                '::',
                'free-soul-sistas',
                st.created_at::text,
                'sub_cancelled',
                CASE
                WHEN 'Subscription Recurring Order' = ANY (o.tags) THEN 'recurring'
                WHEN 'Subscription First Order' = ANY (o.tags) THEN 'first'
                END,
                s.id::text,
                o.id::text
                )
                )                                                    AS event_id,
                'free-soul-sistas'                                   AS tenant_id,
                st.created_at                                        AS event_time,
                'sub_cancelled'                                      AS event_type,
                'cancelled'                                          AS status_after,
                st.subscription_id                                   AS subscription_id,
                s.customer_id                                        AS customer_id,
                CASE
                WHEN 'Subscription Recurring Order' = ANY (o.tags) THEN 'recurring'
                WHEN 'Subscription First Order' = ANY (o.tags) THEN 'first'
                END                                              AS revenue_type,
                coalesce(((o.total_price - o.total_tax - coalesce(s.delivery_price_amount, 0)) * 100)::bigint, 0)        AS price_cents,
                coalesce((o.total_tax * 100)::bigint, 0)             AS tax_cents,
                coalesce((s.delivery_price_amount * 100)::bigint, 0) AS shipping_cents,
                CASE
                WHEN bp.interval = 'DAY' THEN bp.frequency * 1
                WHEN bp.interval = 'WEEK' THEN bp.frequency * 7
                WHEN bp.interval = 'MONTH' THEN bp.frequency * 30
                WHEN bp.interval = 'YEAR' THEN bp.frequency * 365
                ELSE 30
                END                                              AS interval_days,
                sp.name                                               AS plan_id,
                NULL                                                 AS region,
                s.source                                             AS channel,
                s.currency_code                                      AS currency,
                coalesce(s.cancellation_reason, 'Other')             AS cancellation_reason,
                NULL                                                 AS pause_reason
                FROM subscription_transitions st
                JOIN subscriptions s ON st.subscription_id = s.id
                JOIN orders o on s.origin_order_id = o.id
                LEFT JOIN billing_policies bp ON bp.subscription_id = s.id
                LEFT JOIN selling_plans sp ON sp.id = bp.selling_plan_id
                WHERE to_state IN ('cancelled', 'failed')
                AND o.state NOT IN ('cancelled', 'refunded')
                ) AS query
                WHERE event_time >= '2025-09-01' and event_time < '2025-10-01'
                ORDER BY event_time DESC
                LIMIT $1 OFFSET $2;
              args_mapping: |
                root = [2500, this.batch_number * 2500]
        result_map: "root.sub_cancelled = this"
    # Sub Resumed / Sub Reactivated
    - branch:
        processors:
          - sql_raw:
              driver: postgres
              dsn: "postgres://postgres:password@db:5432/shopify_data_pruned?sslmode=disable"
              query: |
                SELECT *
                FROM (
                SELECT md5(
                concat_ws(
                '::',
                'free-soul-sistas',
                curr_st.created_at::text,
                CASE prev_st.to_state
                WHEN 'paused' THEN 'sub_resumed'
                WHEN 'cancelled' THEN 'sub_reactivated'
                END,
                CASE
                WHEN 'Subscription Recurring Order' = ANY (o.tags) THEN 'recurring'
                WHEN 'Subscription First Order' = ANY (o.tags) THEN 'first'
                END,
                s.id::text,
                o.id::text
                )
                )                                                    AS event_id,
                'free-soul-sistas'                                   AS tenant_id,
                curr_st.created_at                                   AS event_time,
                CASE prev_st.to_state
                WHEN 'paused' THEN 'sub_resumed'
                WHEN 'cancelled' THEN 'sub_reactivated'
                END                                              AS event_type,
                'active'                                             AS status_after,
                curr_st.subscription_id                              AS subscription_id,
                s.customer_id                                        AS customer_id,
                CASE
                WHEN 'Subscription Recurring Order' = ANY (o.tags) THEN 'recurring'
                WHEN 'Subscription First Order' = ANY (o.tags) THEN 'first'
                END                                              AS revenue_type,
                coalesce(((o.total_price - o.total_tax - coalesce(s.delivery_price_amount, 0)) * 100)::bigint, 0)        AS price_cents,
                coalesce((o.total_tax * 100)::bigint, 0)             AS tax_cents,
                coalesce((s.delivery_price_amount * 100)::bigint, 0) AS shipping_cents,
                CASE
                WHEN bp.interval = 'DAY' THEN bp.frequency * 1
                WHEN bp.interval = 'WEEK' THEN bp.frequency * 7
                WHEN bp.interval = 'MONTH' THEN bp.frequency * 30
                WHEN bp.interval = 'YEAR' THEN bp.frequency * 365
                ELSE 30
                END                                              AS interval_days,
                sp.name                                              AS plan_id,
                NULL                                                 AS region,
                s.source                                             AS channel,
                s.currency_code                                      AS currency,
                NULL                                                 AS cancellation_reason,
                NULL                                                 AS pause_reason
                FROM subscription_transitions curr_st
                JOIN subscription_transitions prev_st
                ON prev_st.subscription_id = curr_st.subscription_id
                AND prev_st.sort_key = curr_st.sort_key - 10
                JOIN subscriptions s ON curr_st.subscription_id = s.id
                JOIN orders o on s.origin_order_id = o.id
                LEFT JOIN billing_policies bp ON bp.subscription_id = s.id
                LEFT JOIN selling_plans sp ON sp.id = bp.selling_plan_id
                WHERE curr_st.to_state = 'active'
                AND curr_st.sort_key != 10
                AND prev_st.to_state IN ('paused', 'cancelled')
                AND o.state NOT IN ('cancelled', 'refunded')
                ) AS query
                WHERE event_time >= '2025-09-01' and event_time < '2025-10-01'
                ORDER BY event_time DESC
                LIMIT $1 OFFSET $2;
              args_mapping: |
                root = [2500, this.batch_number * 2500]
        result_map: "root.sub_resumed_reactivated = this"
    # Dunning Entered
    - branch:
        processors:
          - sql_raw:
              driver: postgres
              dsn: "postgres://postgres:password@db:5432/shopify_data_pruned?sslmode=disable"
              query: |
                SELECT *
                FROM (
                SELECT md5(
                concat_ws(
                '::',
                'free-soul-sistas',
                d.created_at::text,
                'dunning_entered',
                CASE
                WHEN 'Subscription Recurring Order' = ANY (o.tags) THEN 'recurring'
                WHEN 'Subscription First Order' = ANY (o.tags) THEN 'first'
                END,
                s.id::text,
                o.id::text
                )
                )                                                    AS event_id,
                'free-soul-sistas'                                   AS tenant_id,
                d.created_at                                         AS event_time,
                'dunning_entered'                                    AS event_type,
                'dunning'                                            AS status_after,
                d.subscription_id                                    AS subscription_id,
                s.customer_id                                        AS customer_id,
                CASE
                WHEN 'Subscription Recurring Order' = ANY (o.tags) THEN 'recurring'
                WHEN 'Subscription First Order' = ANY (o.tags) THEN 'first'
                END                                              AS revenue_type,
                coalesce(((o.total_price - o.total_tax - coalesce(s.delivery_price_amount, 0)) * 100)::bigint, 0)        AS price_cents,
                coalesce((o.total_tax * 100)::bigint, 0)             AS tax_cents,
                coalesce((s.delivery_price_amount * 100)::bigint, 0) AS shipping_cents,
                CASE
                WHEN bp.interval = 'DAY' THEN bp.frequency * 1
                WHEN bp.interval = 'WEEK' THEN bp.frequency * 7
                WHEN bp.interval = 'MONTH' THEN bp.frequency * 30
                WHEN bp.interval = 'YEAR' THEN bp.frequency * 365
                ELSE 30
                END                                              AS interval_days,
                sp.name                                              AS plan_id,
                NULL                                                 AS region,
                o.source                                             AS channel,
                o.currency                                           AS currency,
                NULL                                                 AS cancellation_reason,
                NULL                                                 AS pause_reason
                FROM dunning_counters d
                JOIN subscriptions s on d.subscription_id = s.id
                JOIN orders o on s.origin_order_id = o.id
                LEFT JOIN billing_policies bp ON bp.subscription_id = s.id
                LEFT JOIN selling_plans sp ON sp.id = bp.selling_plan_id
                WHERE d.type = 'FailedBillingCounter'
                AND d.state = 'closed'
                AND o.state NOT IN ('cancelled', 'refunded')
                ) AS query
                WHERE event_time >= '2025-09-01' and event_time < '2025-10-01'
                ORDER BY event_time DESC
                LIMIT $1 OFFSET $2;
              args_mapping: |
                root = [2500, this.batch_number * 2500]
        result_map: "root.dunning_entered = this"
    # Dunning Exited
    - branch:
        processors:
          - sql_raw:
              driver: postgres
              dsn: "postgres://postgres:password@db:5432/shopify_data_pruned?sslmode=disable"
              query: |
                SELECT *
                FROM (
                SELECT md5(
                concat_ws(
                '::',
                'free-soul-sistas',
                d.updated_at::text,
                'dunning_exited',
                CASE
                WHEN 'Subscription Recurring Order' = ANY (o.tags) THEN 'recurring'
                WHEN 'Subscription First Order' = ANY (o.tags) THEN 'first'
                END,
                s.id::text,
                o.id::text
                )
                )                                                                    AS event_id,
                'free-soul-sistas'                                                   AS tenant_id,
                d.updated_at                                                         AS event_time,
                'dunning_exited'                                                     AS event_type,
                'cancelled'                                                          AS status_after,
                d.subscription_id                                                    AS subscription_id,
                s.customer_id                                                        AS customer_id,
                CASE
                WHEN 'Subscription Recurring Order' = ANY (o.tags) THEN 'recurring'
                WHEN 'Subscription First Order' = ANY (o.tags) THEN 'first'
                END                                                              AS revenue_type,
                coalesce(((o.total_price - o.total_tax - coalesce(s.delivery_price_amount, 0)) * 100)::bigint, 0)        AS price_cents,
                coalesce((o.total_tax * 100)::bigint, 0)                             AS tax_cents,
                coalesce((s.delivery_price_amount * 100)::bigint, 0)                 AS shipping_cents,
                CASE
                WHEN bp.interval = 'DAY' THEN bp.frequency * 1
                WHEN bp.interval = 'WEEK' THEN bp.frequency * 7
                WHEN bp.interval = 'MONTH' THEN bp.frequency * 30
                WHEN bp.interval = 'YEAR' THEN bp.frequency * 365
                ELSE 30
                END                                                              AS interval_days,
                sp.name                                                               AS plan_id,
                NULL                                                                 AS region,
                o.source                                                             AS channel,
                o.currency                                                           AS currency,
                coalesce(s.cancellation_reason,
                'Failed due to exceeding maximum allowed failed billings.') AS cancellation_reason,
                NULL                                                                 AS pause_reason
                FROM dunning_counters d
                JOIN subscriptions s on d.subscription_id = s.id
                JOIN orders o on s.origin_order_id = o.id
                LEFT JOIN billing_policies bp ON bp.subscription_id = s.id
                LEFT JOIN selling_plans sp ON sp.id = bp.selling_plan_id
                WHERE d.type = 'FailedBillingCounter'
                AND d.state = 'closed'
                AND failed_cycles = max_failed_cycles
                AND o.state NOT IN ('cancelled', 'refunded')
                ) AS query
                WHERE event_time >= '2025-09-01' and event_time < '2025-10-01'
                ORDER BY event_time DESC
                LIMIT $1 OFFSET $2;
              args_mapping: |
                root = [2500, this.batch_number * 2500]
        result_map: "root.dunning_exited = this"
    # Dunning Recovered
    - branch:
        processors:
          - sql_raw:
              driver: postgres
              dsn: "postgres://postgres:password@db:5432/shopify_data_pruned?sslmode=disable"
              query: |
                SELECT *
                FROM (
                SELECT md5(
                concat_ws(
                '::',
                'free-soul-sistas',
                d.updated_at::text,
                'dunning_recovered',
                CASE
                WHEN 'Subscription Recurring Order' = ANY (o.tags) THEN 'recurring'
                WHEN 'Subscription First Order' = ANY (o.tags) THEN 'first'
                END,
                s.id::text,
                o.id::text
                )
                )                                                    AS event_id,
                'free-soul-sistas'                                   AS tenant_id,
                d.updated_at                                         AS event_time,
                'dunning_recovered'                                  AS event_type,
                'active'                                             AS status_after,
                d.subscription_id                                    AS subscription_id,
                s.customer_id                                        AS customer_id,
                CASE
                WHEN 'Subscription Recurring Order' = ANY (o.tags) THEN 'recurring'
                WHEN 'Subscription First Order' = ANY (o.tags) THEN 'first'
                END                                              AS revenue_type,
                coalesce(((o.total_price - o.total_tax - coalesce(s.delivery_price_amount, 0)) * 100)::bigint, 0)        AS price_cents,
                coalesce((o.total_tax * 100)::bigint, 0)             AS tax_cents,
                coalesce((s.delivery_price_amount * 100)::bigint, 0) AS shipping_cents,
                CASE
                WHEN bp.interval = 'DAY' THEN bp.frequency * 1
                WHEN bp.interval = 'WEEK' THEN bp.frequency * 7
                WHEN bp.interval = 'MONTH' THEN bp.frequency * 30
                WHEN bp.interval = 'YEAR' THEN bp.frequency * 365
                ELSE 30
                END                                              AS interval_days,
                sp.name                                               AS plan_id,
                NULL                                                 AS region,
                o.source                                             AS channel,
                o.currency                                           AS currency,
                NULL                                                 AS cancellation_reason,
                NULL                                                 AS pause_reason
                FROM dunning_counters d
                JOIN subscriptions s on d.subscription_id = s.id
                JOIN orders o on s.origin_order_id = o.id
                LEFT JOIN billing_policies bp ON bp.subscription_id = s.id
                LEFT JOIN selling_plans sp ON sp.id = bp.selling_plan_id
                WHERE d.type = 'FailedBillingCounter'
                AND d.state = 'closed'
                AND failed_cycles < max_failed_cycles
                AND o.state NOT IN ('cancelled', 'refunded')
                ) AS query
                WHERE event_time >= '2025-09-01' and event_time < '2025-10-01'
                ORDER BY event_time DESC
                LIMIT $1 OFFSET $2;
              args_mapping: |
                root = [2500, this.batch_number * 2500]
        result_map: "root.dunning_recovered = this"
    # Order Created Addon
    - branch:
        processors:
          - sql_raw:
              driver: postgres
              dsn: "postgres://postgres:password@db:5432/shopify_data_pruned?sslmode=disable"
              query: |
                select *
                from (
                SELECT
                md5(
                concat_ws(
                '::',
                'free-soul-sistas',
                li.updated_at::text,
                'order_created',
                'addon',
                s.id::text,
                o.id::text
                )
                )                                                    AS event_id,
                'free-soul-sistas'           AS tenant_id,
                li.updated_at                                        AS event_time,
                'order_created'                                      AS event_type,
                'active'                                             AS status_after,
                so.subscription_id                                   AS subscription_id,
                o.customer_id                                        AS customer_id,
                'addon'                                              AS revenue_type,
                COALESCE((li.total * 100)::bigint, 0) AS price_cents,
                0             AS tax_cents,
                0 AS shipping_cents,
                CASE
                WHEN bp.interval = 'DAY' THEN bp.frequency * 1
                WHEN bp.interval = 'WEEK' THEN bp.frequency * 7
                WHEN bp.interval = 'MONTH' THEN bp.frequency * 30
                WHEN bp.interval = 'YEAR' THEN bp.frequency * 365
                ELSE 30
                END                                                  AS interval_days,
                sp.name                                              AS plan_id,
                NULL                                                 AS region,
                o.source                                             AS channel,
                o.currency                                           AS currency,
                NULL                                                 AS cancellation_reason,
                NULL                                                 AS pause_reason
                from line_items li
                LEFT JOIN orders o on o.id = li.order_id
                LEFT JOIN subscription_orders so ON o.id = so.order_id
                LEFT JOIN subscriptions s ON so.subscription_id = s.id
                LEFT JOIN billing_policies bp ON bp.subscription_id = s.id
                LEFT JOIN selling_plans sp ON sp.id = bp.selling_plan_id
                WHERE li.deleted_at is null
                and li.properties LIKE '%{"name"=>"one_off", "value"=>"true"}%'
                OR li.properties LIKE '%{"value"=>"true", "name"=>"one_off"}%'
                ) as query
                WHERE event_time >= '2025-09-01' and event_time < '2025-10-01'
                ORDER BY event_time DESC
                LIMIT $1 OFFSET $2;
              args_mapping: |
                root = [2500, this.batch_number * 2500]
        result_map: "root.order_created_addon = this"

    # Customer Created
    - branch:
        processors:
          - sql_raw:
              driver: postgres
              dsn: "postgres://postgres:password@db:5432/shopify_data_pruned?sslmode=disable"
              query: |
                SELECT *
                FROM (
                SELECT md5(
                concat_ws(
                '::',
                'free-soul-sistas',
                c.created_at::text,
                'customer_created',
                c.id::text
                )
                )                                                    AS event_id,
                'free-soul-sistas'                                   AS tenant_id,
                c.created_at                                         AS event_time,
                'customer_created'                                   AS event_type,
                'active'                                             AS status_after,
                NULL                                                 AS subscription_id,
                c.id                                                 AS customer_id,
                'first'                                              AS revenue_type,
                0                                                    AS price_cents,
                0                                                    AS tax_cents,
                0                                                    AS shipping_cents,
                0                                                    AS interval_days,
                NULL                                                 AS plan_id,
                NULL                                                 AS region,
                NULL                                                 AS channel,
                NULL                                                 AS currency,
                NULL                                                 AS cancellation_reason,
                NULL                                                 AS pause_reason
                FROM customers c
                ) AS query
                WHERE event_time >= '2025-09-01' and event_time < '2025-10-01'
                ORDER BY event_time DESC
                LIMIT $1 OFFSET $2;
              args_mapping: |
                root = [2500, this.batch_number * 2500]
        result_map: "root.customer_created = this"

    # Customer Cancelled
    - branch:
        processors:
          - sql_raw:
              driver: postgres
              dsn: "postgres://postgres:password@db:5432/shopify_data_pruned?sslmode=disable"
              query: |
                SELECT *
                FROM (
                SELECT md5(
                concat_ws(
                '::',
                'free-soul-sistas',
                s_last.cancellation_date::text,
                'customer_cancelled',
                c.id::text
                )
                )                                                    AS event_id,
                'free-soul-sistas'                                   AS tenant_id,
                s_last.cancellation_date                             AS event_time,
                'customer_cancelled'                                 AS event_type,
                'cancelled'                                          AS status_after,
                s_last.id                                            AS subscription_id,
                c.id                                                 AS customer_id,
                'recurring'                                          AS revenue_type,
                0                                                    AS price_cents,
                0                                                    AS tax_cents,
                0                                                    AS shipping_cents,
                0                                                    AS interval_days,
                NULL                                                 AS plan_id,
                NULL                                                 AS region,
                NULL                                                 AS channel,
                NULL                                                 AS currency,
                s_last.cancellation_reason                           AS cancellation_reason,
                NULL                                                 AS pause_reason
                FROM customers c
                JOIN (
                SELECT s.customer_id,
                MAX(s.cancellation_date) AS last_cancelled_at
                FROM subscriptions s
                GROUP BY s.customer_id
                HAVING COUNT(*) > 0
                AND BOOL_AND(s.state = 'cancelled')
                ) all_cancelled ON all_cancelled.customer_id = c.id
                JOIN LATERAL (
                SELECT s.*
                FROM subscriptions s
                WHERE s.customer_id = c.id
                AND s.state = 'cancelled'
                AND s.cancellation_date = all_cancelled.last_cancelled_at
                ORDER BY s.id DESC
                LIMIT 1
                ) s_last ON TRUE
                ) AS query
                WHERE event_time >= '2025-09-01' AND event_time < '2025-10-01'
                ORDER BY event_time DESC  
                LIMIT $1 OFFSET $2;
              args_mapping: |
                root = [2500, this.batch_number * 2500]
        result_map: "root.customer_cancelled = this"

    # Customer Paused
    - branch:
        processors:
          - sql_raw:
              driver: postgres
              dsn: "postgres://postgres:password@db:5432/shopify_data_pruned?sslmode=disable"
              query: |
                SELECT *
                FROM (
                SELECT md5(
                concat_ws(
                '::',
                'free-soul-sistas',
                s_last.paused_at::text,
                'customer_paused',
                c.id::text
                )
                )                                                    AS event_id,
                'free-soul-sistas'                                   AS tenant_id,
                s_last.paused_at                                    AS event_time,
                'customer_paused'                                    AS event_type,
                'paused'                                             AS status_after,
                s_last.id                                            AS subscription_id,
                c.id                                                 AS customer_id,
                'recurring'                                          AS revenue_type,
                0                                                    AS price_cents,
                0                                                    AS tax_cents,
                0                                                    AS shipping_cents,
                0                                                    AS interval_days,
                NULL                                                 AS plan_id,
                NULL                                                 AS region,
                NULL                                                 AS channel,
                NULL                                                 AS currency,
                NULL                                                 AS cancellation_reason,
                NULL                                                 AS pause_reason
                FROM customers c
                JOIN (
                SELECT s.customer_id,
                MAX(s.paused_at) AS last_paused_at
                FROM subscriptions s
                GROUP BY s.customer_id
                HAVING COUNT(*) > 0
                AND BOOL_AND(s.state = 'paused')
                ) all_paused ON all_paused.customer_id = c.id
                JOIN LATERAL (
                SELECT s.*
                FROM subscriptions s
                WHERE s.customer_id = c.id
                AND s.state = 'paused'
                AND s.paused_at = all_paused.last_paused_at
                ORDER BY s.id DESC
                LIMIT 1
                ) s_last ON TRUE
                ) AS query
                WHERE event_time >= '2025-09-01' AND event_time < '2025-10-01'
                ORDER BY event_time DESC                
                LIMIT $1 OFFSET $2;
              args_mapping: |
                root = [2500, this.batch_number * 2500]
        result_map: "root.customer_paused = this"

    - mapping: |
        root.queries = {
          "order_created": this.order_created,
          "sub_created": this.sub_created,
          "sub_paused": this.sub_paused,
          "sub_cancelled": this.sub_cancelled,
          "sub_resumed_reactivated": this.sub_resumed_reactivated,
          "dunning_entered": this.dunning_entered,
          "dunning_exited": this.dunning_exited,
          "dunning_recovered": this.dunning_recovered,
          "order_created_addon": this.order_created_addon,
          "customer_created": this.customer_created,
          "customer_cancelled": this.customer_cancelled,
          "customer_paused": this.customer_paused
        }

pipeline:
  processors:
    - mapping: |
        root = this.queries.order_created.or([]).append(
        this.queries.sub_created.or([]),
        this.queries.sub_paused.or([]), 
        this.queries.sub_cancelled.or([]), 
        this.queries.sub_resumed_reactivated.or([]), 
        this.queries.dunning_entered.or([]),
        this.queries.dunning_exited.or([]),
        this.queries.dunning_recovered.or([]),
        this.queries.order_created_addon.or([]),
        this.queries.customer_created.or([]),
        this.queries.customer_cancelled.or([]),
        this.queries.customer_paused.or([])
        )
    - mapping: |
        root = if this.type() == "array" {
          this.flatten().filter(el -> el != null)
        } else {
          this
        }
    - log:
        level: INFO
        message: "MESSAGES: ${! this.length() }}"
    - switch:
        - check: this.length() == 0
          processors:
            - log:
                level: INFO
                message: "ðŸ˜´ No rows returned from database. Exited"
            - command:
                name: kill
                args_mapping: '[ "1" ]'
    - mapping: |
        root = this
    - unarchive:
        format: json_array
    - dedupe:
        cache: keycache
        key: ${! this.event_id }

output:
  sql_insert:
    driver: clickhouse
    dsn: "clickhouse://${CLICKHOUSE_USER}:${CLICKHOUSE_PASSWORD}@clickhouse:9000/analytics"
    table: events_raw
    columns:
      - tenant_id
      - event_id
      - event_time
      - event_type
      - status_after
      - subscription_id
      - customer_id
      - revenue_type
      - price_cents
      - shipping_cents
      - tax_cents
      - interval_days
      - plan_id
      - region
      - channel
      - currency
      - cancellation_reason
      - pause_reason
    args_mapping: |
      root = [
        this.tenant_id,
        this.event_id,
        this.event_time,
        this.event_type,
        this.status_after,
        this.subscription_id,
        this.customer_id,
        this.revenue_type,
        this.price_cents,
        this.shipping_cents,
        this.tax_cents,
        this.interval_days,
        this.plan_id,
        this.region,
        this.channel,
        this.currency,
        this.cancellation_reason,
        this.pause_reason
      ]
    batching:
      count: 30000
      period: 2s

cache_resources:
  # Redis cache to track processed keys
  - label: keycache
    redis:
      url: redis://redis:6379
      default_ttl: 5s
      retries:
        initial_interval: 500ms
        max_interval: 1s
        max_elapsed_time: 5s
  # Memory cache for batch_count (batch mode)
  - label: batchcache
    memory: {}
